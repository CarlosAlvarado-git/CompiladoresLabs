package compiler.parser;

import java_cup.runtime.Symbol;

parser code
{:
    private Symbol s;
    
    public void syntax_error(Symbol s){
        this.s = s;
    }

    public Symbol getS(){
        return this.s;
}
:};

terminal Int, Boolean, Callout, If, For, Else, Return, Break, Continue, True, 
        False, Void, Class, Program, Id, Digit, Alpha, Hex_digit,
        Decimal_literal,Hex_literal,GREATER, LESS,LESS_EQUAL,GREATER_EQUAL,
        PLUS_EQUAL, ASSIGN, MINUS_EQUAL,EQUAL,NOT_EQUAL,AND,OR, LEFT_PAR,
        RIGHT_PAR,Punto_coma,Mas, Menos,Multiplicacion, Division, Mod, Llave_A,
        Llave_C,Corche_A, Corche_C, Coma, Exclamacion,Comillas, ComillasDoble, ERROR;


non terminal program, field_method_decl, siguiente, siguiente2, siguiente3, if, option, option2,
                block, var_decl, lis_ids, type, statement,corche_else_block,
                assign_op, method_call, method_name, location, expr, callout_arg, bin_op,
                arith_op, rel_op, eq_op, cond_op, literal, alpha_num, int_literal,bool_literal,corche_expresion,exprs,alpha_num_asterisco,
                char_literal, char, string_literal, char_asterisco,corche_call_out,callout_args;

start with program;

program ::= Class Program Llave_A  field_method_decl field_method_decl Llave_C
;

field_method_decl  ::= 
        type siguiente Punto_coma |
        Void LEFT_PAR siguiente RIGHT_PAR block Punto_coma
;

siguiente ::= 
        Id siguiente2 ;

siguiente2 ::= 
        Corche_A int_literal Corche_C |
        siguiente3 ; 

siguiente3 ::=
        type Id siguiente3 ;

block ::= Llave_A var_decl statement Llave_C 
;

var_decl ::= 
        siguiente3 |;

statement ::=
        location assign_op expr Punto_coma |
        method_call Punto_coma |
        if |
        For Id ASSIGN expr Coma expr block |
        Return option2 Punto_coma|
        Break |
        Continue |
        block |
;


if ::=
    If LEFT_PAR expr RIGHT_PAR block option 
;

option ::=
        Else block | 
;

option2 ::=
        expr | 
;